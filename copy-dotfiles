#!/usr/bin/env perl
use strict;
use warnings;
use utf8;

# gnu_compat: --opt="..." is allowed.
# no_bundling: single character option is not bundled.
# no_ignore_case: no ignore case on long option.
use Getopt::Long qw(:config gnu_compat no_bundling no_ignore_case);
use FindBin ();
use Pod::Usage;
use File::Spec::Functions qw(catfile);
use File::Basename qw(dirname);
use Perl6::Say;
use File::Path qw(rmtree);

use lib "$FindBin::Bin/lib";
use Dotto::Util qw(get_home_from_user determine_user_and_home load_config convert_filename install);


sub usage () {
    pod2usage(-verbose => 1);
}


my $needhelp = 0;
my $from_directory;
my $to_directory;
my $config_file;
my $dry_run = 0;
my $force_overwrite = 0;
my $username;
GetOptions(
    'h|help'
        => \$needhelp,
    'u|username=s'
        => \$username,
    'c|config-file=s'
        => \$config_file,
    'dry-run'
        => \$dry_run,
    'f|force'
        => \$force_overwrite,
    'i|from-directory=s'
        => \$from_directory,
    'o|to-directory=s'
        => \$to_directory,
) or usage;
usage if $needhelp;


unless (defined $username) {
    $username = determine_user;
}

if (!defined $config_file && exists $ENV{DOTTORC}) {
    $config_file = $ENV{DOTTORC};
}
my $c = load_config($config_file);

unless (defined $from_directory) {
    if (exists $c->{from_directory}) {
        $from_directory = $c->{from_directory};
    }
    unless (defined $from_directory) {
        die "error: input directory is undefined,"
            . "please specify with -i or --from-directory\n";
    }
}
unless (defined $to_directory) {
    if (exists $c->{to_directory}) {
        $to_directory = $c->{to_directory};
    }
    unless (defined $to_directory) {
        die "error: output directory is undefined,"
            . "please specify with -o or --to-directory\n";
    }
}
my @files = @{$c->{files}};

# For test, check if file exists before installing.
unless ($force_overwrite) {
    my $exists = 0;
    for my $file (map { convert_filename $c, $_ } @files) {
        my $dest = catfile($to_directory, $file);
        if (-e $dest) {
            warn "warning: copy-dotfiles: File exists '$dest'.\n";
            $exists = 1;
        }
    }
    exit 1 if $exists;
}

# Install dotfiles to $to_directory.
# but if path $dest exists even if $force_overwrite == 0
# (maybe problem like race condition), exit with error.
for my $file (@files) {
    my $src  = catfile($from_directory, $file);
    my $dest = catfile($to_directory, convert_filename $c, $file);

    if ($dry_run) {
        say "Copy $src -> $dest";
        next;
    }

    if (-e $dest) {
        unless ($force_overwrite) {
            # checked but file exists?
            die "error: copy-dotfiles: File exists '$dest'.\n";
        }
        rmtree($dest);
    }

    install($src, $dest, $username);
}

for my $file (@{$c->{ignore_files}}) {
    my $dest = catfile($to_directory, convert_filename $c, $file);
    if (-e $dest) {
        rmtree($dest);
    }
}




__END__

=head1 NAME

    copy-dotfiles - Copy dotfiles from directory to directory.


=head1 SYNOPSIS

    $ copy-dotfiles -i ~ -o dotfiles [OPTIONS]
    $ copy-dotfiles -i dotfiles -o ~ [OPTIONS]


=head1 OPTIONS

=over 7

=item -i {directory}, --from-directory {directory}

Copy dotfiles to this directory.

=item -o {directory}, --to-directory {directory}

Copy dotfiles from this directory.

=item -h, --help

Show help.

=item -u {user}, --username {user}

Owner of copied dotfiles.

=item -c {config-file}, --config-file {config-file}

Config file path to get dotfiles list.

=item -f, --force

Overwrite dotfiles if they exist.

=item -v, --verbose

Output verbose messages.

=back


=head1 AUTHOR

tyru <tyru.exe@gmail.com>
